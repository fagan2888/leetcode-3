# 解题要点-投票

这类题是 `uniq -c | sort -n`, 实际场景是投票计数, 然后统计出得票超过某个比例的候选人.

## 通用解法

1. 哈希计数.
2. 按计数排序 key, 或者用优化队列.

如果只是求 top N, 那么不用排序, 用优先队列即可.

## 绝对得票统计

正常的计数是计算每一个候选人的绝对投票数.

## 相对得票统计

不同于绝对得票统计法, 比例得票统计将一张选票看作是 1 个赞成票和 n-1 个反对票, 那么当某个候选人得了 1 票后, 他的计数加 1, 其他所有人的计数都要减 1. 这样可以得出一些有趣的结论:

**计数大于 0**: 显然, 候选人得票超过半数.
**计数大于 1/2**, 候选人得票超过 3/4.

还有更多的结论, 都对应一个公式:

	vote = (count + 1)/2

各个变量用的是比例.

## 摩尔投票(Moore Voting)

### 半数和鸽笼原理

如果有人得票超过半数, 采用相对计票法, 反对票肯定小于赞成票.

	ret = -1;
	cnt = 0;
	for(auto n : nums){
		if(cnt == 0){
			cnt ++;
			ret = n;
		}else if(ret == n){
			cnt ++;
		}else{
			cnt --;
		}
	}
	return cnt > 0? ret : -1;

**任何不是半数的那个人上台, 最终都会被半数者选下来.**

### 摩尔投票

摩尔投票采用两趟遍历. 第一趟遍历是为了缩小候选人范围, 第二趟进行绝对计票.

假设我们想求得票超过 1/n 的候选人. 显然, 最多只有 n-1 个候选人最终胜出, 当然, 也可能无人胜出(所以需要第二趟遍历). 

第一趟遍历步骤:

1. 如果台上有空位, 那么拿到票的人上台.
2. 如果是台上的人得票, 其他候选人的计数不减 1; 如果是台下的人得票, 所有候选人的计数减 1.
3. 淘汰计数小于 1 的候选人.

如何想出这个算法的, 我不知道.

#### 证明

假设目标先计 `total * 1/n` 的票数上台(还有至少 1 张没计, 因为超过 1/n), 接着通过 n-2 张票将其它人也选上台, 然后用 1 张票将这 n-2 个人选下台. 这时目标得票减 1. 如果想将其先下台, 至少进行 total/n 次这种操作, 每次消耗 n-1 张选票.
	
	total/n * (n-1) = total * (n-1)/n

所以上面的公式需要的数量无法满足. 因为其它人无法获得 (n-1)/n 比例的选票, 它们只能得到最多 (n-1)/n - 1 张.

如果不用上面的方法, 每一轮消耗的选票会更多.

由此证明, 目标最终一定会在台上.
