# 穷举法(Brute Force/Exhaustion)

穷举的方式有树遍历和图遍历两种, 从出发点到终点(叶子节点)的路径就是一个解.

**对于条件遍历, 一定不要犯静态分析的错误, 要分析递归前和递归后两种情况, 两种情况都要分析.**

## 树遍历: 渐进式

### 渐进式(一分渐进式): 链式渐进

将问题拆分成一个父问题(原子问题)和一个子问题(剩下的), 父问题有两种状态: 被跳过或者被解决. 进一步递归地去解决子问题.

	func rc(pre_path, remain){
		root, remain2 = remain.split();
		trc(pre_path, remain2); // 父问题被跳过
		trc(pre_path + proc(root), remain2); // 父问题被解决
	}

### 二分渐进式

将问题二分后, 不再进行二分, 而是尝试以先后不同顺序递归消减左问题或者右问题.

* 尝试解决左边问题, 再和右边未解决的问题一起递归.
* 尝试解决右边问题, 再和左边未解决的问题一起递归.
* 所以, 要将左右问题拷贝.

````
func brc(pre_path, left, right){
	l = copy(left); r = copy(right);
	p1 = pre_path + l.pop();
	brc(p1, l, right);
	p2 = pre_path + r.pop();
	brc(p2, left, r);
}
````
### N分渐进式

将问题N分.

	func nrc(pre_path, segments[]){
		...
	}

## 图遍历: 跳跃式(组合式)

这种方式在解决求组合(子集)的问题时比较经典.

每一个问题不像树模型那样有唯一的一个入口(即根节点), 而是有多个入口. 问题本身就被入口所分割, 当选择任何一个入口时, 之前的问题都不需要去解决.

例如求一个有序集合的子集, 那么任何一个元素都是一个入口, 而这个入口元素之后的所有元素组成一个待解决的问题.

以 [1,2,3] 来举例, 1, 2, 3 是 3 个入口, 对应每一个入口, [2,3], [3], [] 就是等解决的问题.

因为选择了不同的入口之后, 问题自动被缩小了, 所以正好可以使用递归来解决.

	func grc(pre_path, remain[]){
		for(entrance, remain2 : remain){
			grc(pre_path + proc(entrance), remain2);
		}
	}

## 优化

缓存中间结果.
