# 解题要点-归位

## 单指针归位(循环交换)

从头开始遍历数组, 如果元素错位, 将其交换到正确的位置. 如果交换来的元素错位, 继续交换, 直到交换来的元素也归位.

	for(int i=0; i<nums.size(); i++){
		while(1){
			if(nums[i] == i + 1){
				break;
			}
			int idx = nums[i] - 1;
			if(nums[i] != nums[idx]){
				swap(nums[i], nums[idx]);
			}
		}
	}

## 标记归位(正负交替交换)

因为元素是正数, 所以, 只需要将目标位的元素改成负数, 那就说明目标位的值已经归位了. 例如

	[2, 1]

对第 1 个元素处理后变成

	[2, -1]

说明 2 已经被交换到正确的位置了. 但是, -1(+1) 还没有. 不过, 不用担心, 继续遍历将处理到 -1. 取绝对值即可. 这种思路其实是用一个编码存储两个信息, 如果编码设计得好, 可以存储更多的信息.

### 判断是否错位的两种方式

#### 直观思维

当前位不是正确的值:

	nums[i] != i;

#### 逆向思维

如果要交换, 当前值和目标值是不同对象:

	nums[i] != nums[nums[i]]

如果两者是同一个位置, 所以相等, 那就是不错位.

## 多指针归位

使用2个指针或者3个指针遍历, 这2个指针或者3个指针的元素做一次交换后, 可减少一次错位.

例如快排的 partition 操作.

### Partition

见"数组"一文, Partition 可做二分, 三分.

