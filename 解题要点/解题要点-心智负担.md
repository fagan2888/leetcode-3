# 解题要点-心智负担

对于有实际工程经验的人来说, 做所谓算法题会有许多心智负担, 因为为了快速解题, 会违反很多工程实践.

## Tricky

有不少题存在所谓 Tricky 的地方, 想到就能解出, 想不到就是做不出, 属于经验的积累, 很难从逻辑上分析和推导出来.

但是, 并不是所有的"算法题"都需要 Tricky, 有些题仅仅是编码熟练度的问题, 就是要求大量的训练. 这一点在"概述"里有提到.

## 修改数据源

工程实践上对于读操作(如查找), 一般不推荐修改数据源. 但是, 很多题都直接修改输入(数据源), 代码运行后, 数据源被修改. 没关系!

这一点很重要, 因为默认是可以修改数据源的. 其实, 不能把算法题中的输入等同于工程上的数据输入, 而应该理解为工程上的数据集, 运行于其上的算法当然可以修改算法要操作的数据集.

程序 = 算法 + 数据结构

题目的输入就是我们程序要处理的数据结构, 其读写权限都属于程序.

## 函数定义

不用担心函数名和函数参数违反工程实际, 怎么方便怎么来. const 引用, 不存在的事, 要多打"const"几个字符, 不要! 因为要修改参数所以传指针? 不要, 直接传引用, 引用在代码上写法更简洁, 特别是 STL 容器使用指针不方便(如 vector).

复用函数参数中的变量? 是的, 这样可以少定义一个变量名.

## 标准类库的使用

例如对于 C++ 来说, STL 的各种容器和算法是可以使用的, unordered_map(hash map), priority_queue, reverse(), swap, sort(), copy(), 这些, 都可以用, 除非题目是考察这些类和方法的实现.

**不要用 C++ STL 的 stack 容器, 功能太少, 连 clear() 方法都没有, WTF!**

set/map 用 count() 来判断是否存在, 即 contains(), 命名不好.

C/C++ 指针就是迭代器.

## 变量命名

变量命名要尽量简化, 例如 i, j, m, n, s, e, hi, lo 等等, 因为这样写代码比较快.

## 代码 bug free

代码要一次编译运行得出正确结果, 既不能有 typo, 也不能有逻辑错误, 对类库和函数的记忆要准确. 没有所谓的调试, 只能通过人眼排查代码.

## 递归栈不算空间占用?

有时候, 题目认为递归栈 O(log N) 递归深度所占用的空间算常量空间. 虽然事实上不是!

## 边界参与计算

正常来说, 边界如 -inf, +inf 是不能参与计算. 但为了简化代码逻辑, 可以使用 INT_MIN, INT_MAX, 就是假设正常的计算结果不会溢出 32 位整数, 即使溢出边界也没关系, 仍然满足大小关系.

如果可能溢出 32 位整数, 那么可以取边界为 INT_MIN/2, INT_MAX/2.

## 编码时迭代优化

编写代码时, 可以先不进行优化, 等把完整的逻辑写完后, 再加入优化分支. 用螺旋迭代的方式.

## 逆向思维

见"直观与逆向"一文. 逆向思维是大多数人所缺少的一种思维方式, 因为它需要推演到下一步之后再倒推. 

## 在 for 循环中修改循环变量要小心

	for(int i=0; i<n; i++){
		if(i == 4){
			i = 2; // 下一次循环从 3 开始!
		}
	}

注意, 要将循环修改为目标节点的**前一个**.

## 解题前先把要点描述清楚

在解题之前, 需要把解题要点描述清楚, 然后再进行编码, 千万不能在心里进行逻辑分析, 而应该讲述出来.
