# 解题要点-差值

有一类问题, 例如股票买卖, Water Trap 等, 属于在数值序列上求差值的同一类问题. 这类问题的几个关键点:

* 上升沿(区间): 在一段区间内, 子序列的数值单调递增.
* 下降沿(区间): 在一段区间内, 子序列的数值单调递减.
* 最大值
* 最小值

因为数值序列可以画成**折线图***, 所以上面的名词很容易理解.

## 差值极值

整个序列内的差值极值并不是最大值减最小值, 因为最小值可能出现在最大值后面. 所以, 应该在遍历过程中, 记录遇到的最小值, 并用当前的值减去最小值得到差值. 对这样的差值求最大值.

	int ret = 0;
	int low = INT_MAX;
	for(auto n : num){
		low = min(low, n);
		ret = max(ret, n - low);
	}

对应的就是股票的最佳买点和最佳卖点.

## 差值累积

查看折线图, 把所有上升沿的最大值减最小值得到的差值累积.

	int ret = 0;
	int lo = nums[0];
	for(int i=1; i<nums.size(); i++){
		lo = min(lo, nums[i]);
		if(i == nums.size()-1 || (nums[i-1] <= nums[i] && nums[i] > nums[i+1])){
			ret += max(0, nums[i] - lo);
			lo = INT_MAX;
		}
	}

或者所有相邻的两点的差值进行累积(忽略负数差值).

	int ret = 0;
	int pre = INT_MAX;
	for(auto n : nums){
		ret += max(0, n - pre);
		pre = n;
	}

对应的就是股票买卖所能获利的最大收益.

## 股票买卖

进行交易回测时, 要求最多交易 n 次, 如何获利最大?

### 最多交易 1 次

假设每一天都卖出, 那么买点是该天之前的最低值. 统计收益的最大值即可.

### 最多交易 2 次

找出 3 次可进行完整的交易的序列(即找 3 段上升沿), 通过组合可算出只交易 2 次时的最大收益, 记录这两次交易的收益和买卖点. 这样就剩下 2 段上升沿了, 继续找下一段, 然后递归处理 3 段的情况.

分析如上, 但代码实现时, 不用找上升沿. 假设每一个点都是卖点, 然后进行上面的逻辑.

### 最多交易 n 次