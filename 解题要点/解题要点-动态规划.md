# 解题要点-动态规划(Dynamic Programming)

动态规划是一种迭代式算法, 每一次操作需要引用之前的 k 个处理结果. 动态规划是一种图遍历, 从第一个入口进入, 后面必然会经过其它全部入口, 所以不需要采用递归图遍历.

规划表用于保存规划的中间结果和最终结果, 有两种方式保存:

1. 全量保存, 但每次只引用 k 个结果
2. 滑动窗口, 需要淘汰策略

**动态规划的关键是找前序节点(多个).**

## 动态规划与分而治之

Wiki 认为动态规划分为 Bottom-Up 和 Top-Down 两种:

* Bottom-Up: 先完成原子问题, 再不断的进化到最终的问题.
* Top-Down: 进最终的问题进行分解, 然后处理, 并不断递归.

虽然说, 动态规划和分而治之的区别在于子问题是否重叠, 但我认为, 只要是将问题分解成较小的问题去解决, 就是"分而治之", 不能因为引入了缓存(Memoiation)就不算分治. 或许在这种场景下, "递归下降"是个比分而治之更好的名字.

好吧, 这样定义:

* 动态规划 = 迭代上升, 累积
* 分而治之 = 递归下降, 消解, 蚕食

## 回溯迭代与推导迭代

回溯是指当前的处理(子)依赖已经处理的一项或者多项(父).

	f(n) = g(f(n-1), ..., f(n-k))

推导指根据当前结果(父)推导出后面的一项或者多项(子), 但因为子项是由多个父项(不同于树只有单一父节点)共同决定的, 所以推导时要引用 f(n) 的旧值 f'(n).

	f(n-1) => f(n) = g(f'(n), f(n-1))
	...
	f(n-k) => f(n) = g(f'(n), f(n-1))

**动态规划的关键点: 找出父节点和转换函数.**

## 图遍历与动态规划

动态规划和穷举法有相同点, 但又有本质的不同.

**相同点:** 两者有些相同点, 都是分而治之的方法, 而且不同的分段(步骤)有父子关系.

**不同点:** 但两者又有着本质的不同, 那就是动态规划对问题的分解是静态一次性的. 另外 , 每一个节点可以有多个父节点(图, 而不是树).

而父子关系可能是静态的, 也可能是动态依赖于处理进度的.

### 静态父子关系

通过某个静态函数, 可以求得某一个节点的所有子节点, 也可以求得某一个节点的父节点.

### 动态父子关系

节点间的父子关系(连通方向)是动态的, 依赖当前节点的前序路径. 所以, 必须从出发点到达某个节点之后, 才能知道这个节点的后序节点(子节点)是哪些.

### A* 算法

F = G(沉没成本) + H(未来成本)
