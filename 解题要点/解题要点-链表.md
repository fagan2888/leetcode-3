# 解题要点

## 辅助头节点(dummy)

链表操作常常会改变头节点的指向, 新建一个辅助节点作为新的头节点可以让操作更容易和简洁. 如果不引入新的头节点的话, 需要在开始时找出新的头节点, 增加了代码复杂度.

## 旗节点(flag)

链表操作大多是移动节点(变换节点的位置), 将符合条件的节点删除, 再插入到旗节点后面.

## 遍历指针节点(prev or curr)

链表遍历时指针到底是指向符合条件的节点, 还是符合条件的前一个节点? 当可能涉及节点删除操作时, 遍历指针应指向符合条件的前一个节点, 因为删除某个节点时, 依赖其前一个节点.

另外, 由于指针指向的是前一个节点, 所以删除符合条件的节点之后, 指针不移动.

## 插入节点操作(insert)

插入操作隐含着插入到目标节点后面. 要插入某个节点, 需要进行两步操作, 1, 把新节点指向目标节点的后面; 2, 目标节点指向新节点.

## 删除节点操作(remove)

要删除某个节点, 只需要一步操作, 把目标的前节点指向目标的后节点即可.

## 快慢指针遍历, 前后指针同时遍历

遍历链表时, 使用两个指针, 这两个指针每一 tick 前进的步数不同, 称为快慢指针. 例如步数比是 1:2, 那么当快指针先进到末尾时, 慢指针就落在中点上. 快慢指针还可用来判断链表形成环路.

如果两个指针遍历的出发间隔不同, 例如前指针出发 n 步之后, 后指针再开始出发, 那么当前指针行进到末尾时, 后指针到达距末尾第 n 个节点上. 相比两次遍历, 使用前后两个指针可以减少计数的次数, 确实能节省一些 CPU.

使用两个指针, 计数器只计数 n 次. 而两次遍历需计数 n + size 次(size 是链表的长度).

### 快慢指针同时遍历找中点

	slow = head;
	fast = head;
	while(fast){
		fast = fast->next;
		if(fast){
			fast = fast->next;
			slow = slow->next;
		}
	}

注意, 上面的遍历逻辑采用了双重判断 fast, 并在第2次移动 fast 的时候, 才移动 slow. 初始化时两个指针都指向头节点.

## 两个指针同时遍历两个不同的链表

如果用两个指针同时遍历两个不同的链表, 每一 tick 指针都前进一步(遍历速度相同), 那么会产生什么有趣的事情呢? 可以思考思考.

## 链表常见操作

### 链表翻转

**将头指针下一个节点删除, 并作为新链表的头节点**

	prev = head;
	while(head->next){
		next = head->next;
		head->next = next->next; // 删除节点
		next->next = prev;
		prev = next;
	}
	return prev;

这种方法比翻转每一个节点要更好, 因为可以随时停止, 停止后, 仍然是一个完整的链表. 可用于翻转 k 个节点.

**翻转每一个节点**

	prev = NULL;
	while(head){
		next = head->next;
		head->next = prev;
		prev = head;
		head = next;
	}
	return prev;

### 链表旋转

**断开再重新拼接**

要旋转 2 次, 那么用快慢指针找到倒数第 3 个, 断开让最后 n 个组成新链表, 旧链表接到新链表后面即可.

**翻转操作实现链表旋转**

翻转整个链表, 然后翻转 k 个元素, 再翻转剩下的所有元素.

	1,2,3,4,5
	5,4,3,2,1 // 反转整个链表
	4,5,3,2,1 // 反转 2 个元素
	4,5,1,2,3 // 反转剩下的


* 首尾相连
* 中点: 用快慢指针遍历可得
* 两个指针遍历两个链表, 任何一个到达尾部时, 从另一个头部开始遍历

