# 解题要点

## 辅助头节点(dummy)

链表操作常常会改变头节点的指向, 新建一个辅助节点作为新的头节点可以让操作更容易和简洁. 如果不引入新的头节点的话, 需要在开始时找出新的头节点, 增加了代码复杂度.

## 旗节点(flag)

链表操作大多是移动节点(变换节点的位置), 将符合条件的节点删除, 再插入到旗节点后面.

## 遍历指针节点(prev or curr)

链表遍历时指针到底是指向符合条件的节点, 还是符合条件的前一个节点? 当可能涉及节点删除操作时, 遍历指针应指向符合条件的前一个节点, 因为删除某个节点时, 依赖其前一个节点.

另外, 由于指针指向的是前一个节点, 所以删除符合条件的节点之后, 指针不移动.

## 插入节点操作(insert)

插入操作隐含着插入到目标节点后面. 要插入某个节点, 需要进行两步操作, 1, 把新节点指向目标节点的后面; 2, 目标节点指向新节点.

## 删除节点操作(remove)

要删除某个节点, 只需要一步操作, 把目标的前节点指向目标的后节点即可.

## 快慢指针遍历, 前后指针同时遍历

遍历链表时, 使用两个指针, 这两个指针每一 tick 前进的步数不同, 称为快慢指针. 例如步数比是 1:2, 那么当快指针先进到末尾时, 慢指针就落在中点上. 快慢指针还可用来判断链表形成环路.

如果两个指针遍历的出发间隔不同, 例如前指针出发 n 步之后, 后指针再开始出发, 那么当前指针行进到末尾时, 后指针到达距末尾第 n 个节点上. 相比两次遍历, 使用前后两个指针可以减少计数的次数, 确实能节省一些 CPU.

使用两个指针, 计数器只计数 n 次. 而两次遍历需计数 n + size 次(size 是链表的长度).

## 两个指针同时遍历两个不同的链表

如果用两个指针同时遍历两个不同的链表, 每一 tick 指针都前进一步(遍历速度相同), 那么会产生什么有趣的事情呢? 可以思考思考.
