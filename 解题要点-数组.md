# 解题要点

## 变量使用

为了简化代码, 定义如下下标变量:

	p: 新元素插入在 p 后面
	s: 区间的开始(包含)
	e: 区间的结束(包含)
	b: 区间的开始(包含)
	e: 区间的结束(不包含) std::end()
	m: 中点
	n: 用于遍历
	m, n: 行, 列
	pre: 前序路径, 或者之前的计算结果, 用于向后序的调用传递数据

s, e 在一起时, e 包含
b, e 在一起时, e 不包含

## 中点公式

设数组起点和终点为 s 和 e, 那么中点 m 可以有两个选择:

	m = s + (e-s)/2

或者

	m = s + (e-s+1)/2 // +1中点公式
	m = e - (e-s)/2

当数组的长度为奇数时, 这两个公式算出的中点是一样的. 区别在于当数组的长度是偶数时, 中点偏向哪一边. 特别是当数组长度为 2 的时候, 中点指向第一个还是第二个? 第一个公式指向第一个, 第二个公式指向第二个.

另有中点公式: m = (s+e)/2, 比前面的公式更可能溢出.

## lower_bound 和 upper_bound 以及 lower_bound-1

### upper_bound

	s = 0;
	e = nums.size();
	while(s < e){
		m = s + (e-s)/2;
		if(arr[m] <= t){
			s = m + 1;
		}else{
			e = m;
		}
	}
	return s;

注意, e 的初始值是 `nums.size()`, 而不是 `nums.size()-1`.

### lower_bound

注意, e 的初始值是 `nums.size()`, 而不是 `nums.size()-1`.

	s = 0;
	e = nums.size();
	while(s < e){
		m = s + (e-s)/2;
		if(arr[m] < t){
			s = m + 1;
		}else{
			e = m;
		}
	}
	return s;

### 前一个/lower_bound-1/反向 upper_bound

	e = nums.size(); // 或者 nums.size()-1
	m = e - (e-s)/2;
	if(arr[m] < t){
		s = m;
	}else{
		e = m - 1;
	}
	if(arr[s] < t) return s;
	else           return s-1;

或

	s = -1; // 反向 upper_bound
	e = nums.size() - 1;
	m = e - (e-s)/2;
	if(arr[m] < t){
	    s = m;
	}else{
	    e = m - 1;
	}
	return s;

## 组合 Combination

### 对无重复元素的集合求组合

	void c1(vector<vector<int>> &ret, vector<int> &nums, int s, vector<int> &pre){
	    if(s == nums.size()){
	        return;
	    }   
	    pre.push_back(nums[s]);
	    ret.push_back(pre);
	    c1(ret, nums, s+1, pre);
	    pre.pop_back();
	    c1(ret, nums, s+1, pre);
	}

	void c2(vector<vector<int>> &ret, vector<int> &nums, int s, vector<int> &pre){
	    for(int i=s; i<nums.size(); i++){
	        pre.push_back(nums[i]);
	        ret.push_back(pre);
	        c2(ret, nums, i+1, pre);
	        pre.pop_back();
	    }   
	}

虽然 c1() 因为停止条件导致多递归了一层, 调用次数是 2^(n+1) 次, 但并不比 c2() 的 2^n 次更差, 因为优化方法很简单, 就是在递归前加判断, 让代码不那么简洁而已.

c1() 处理逻辑属于**渐进式**递归, 一次前进一步. c2() 的处理逻辑是**跳跃式(组合式)**递归. 跳跃式比渐进式更容易优化.

个人认为渐进式逻辑上更直观一些.

**c2() 是图遍历, 见"穷举"一文的分析.**

### 对有重复元素的集合求组合

对结果集去重可能是个时间复杂度非常高的操作, 但如果对源数据排序, 那么在生成过程中避免重复, 结果集不需要去重.

关于对含重复元素集合进行组合的一些思考:

* **可以把输入集进行去重, 但保留元素的重复次数**
	* 生成组合时用不同的次数与其它元素进行组合
* **或者一个元素重复不同次数, 用一个新的元素来代表, 例如1=[1], 1.1=[1,1]...**
	* 新的代表元素有序性上大于前面的但不大于后面的元素. 计算时仍按原值计算, 但又不能和原值进行组合.

例如: [1, 1, 2, 3] 转换成 [1, 1.1, 2, 3], 1 和 1.1 不能同时出现在组合中, 但可以分别与其它元素进行组合

c1() 的优化结果如下:

	void cu1(vector<vector<int>> &ret, vector<int> &nums, int s, vector<int> &pre){
	    if(s == nums.size()){
	        return;
	    }
	    // 求重复子集
	    int n = s + 1;
	    while(n < nums.size() && nums[s] == nums[n]){
	        n ++; 
	    }
	    for(int i=s; i<n; i++){
	        pre.push_back(nums[i]);
	        ret.push_back(pre);
	        // 跳过后面的重复元素, 直接与子集后面的元素进行组合
	        cu1(ret, nums, n, pre);
	    }   
	    for(int i=s; i<n; i++){
	        pre.pop_back();
	    }
	    // 跳过全部重复子集
	    cu1(ret, nums, n, pre);
	}

c2() 优化结果如下:

	void cu2(vector<vector<int>> &ret, vector<int> &nums, int s, vector<int> &pre){
	    for(int i=s; i<nums.size(); i++){
	        // 跳过重复子集, 除子集的第一个外
	        if(i > s && nums[i] == nums[-1]){
	            continue;
	        }
	        pre.push_back(nums[i]);
	        ret.push_back(pre);
	        cu2(ret, nums, i+1, pre);
	        pre.pop_back();
	    }
	}

## 排列 Permutation


## 数组旋转



