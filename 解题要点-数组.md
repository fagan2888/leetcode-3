# 解题要点

### 变量使用

为了简化代码, 定义如下下标变量:

	p: 新元素插入在 p 后面
	s: 区间的开始(包含)
	e: 区间的结束(包含)
	m: 中点
	n: 用于遍历

### 中点公式

设数组起点和终点为 s 和 e, 那么中点 m 可以有两个选择:

	m = s + (e-s)/2

或者

	m = s + (e-s+1)/2 // +1中点公式
	m = e - (e-s)/2

当数组的长度为奇数时, 这两个公式算出的中点是一样的. 区别在于当数组的长度是偶数时, 中点偏向哪一边. 特别是当数组长度为 2 的时候, 中点指向第一个还是第二个? 第一个公式指向第一个, 第二个公式指向第二个.

另有中点公式: m = (s+e)/2, 比前面的公式更可能溢出.

### lower_bound 与 upper_bound

lower_bound 与 upper_bound 并不是对称的, 虽然它们的名字是对称的. `lower_bound -1` 与 `upper_bound` 才是对称的. 如果把 `upper_bound` 称为"后一个(after)", 那么"前一个(prior)"对应的是 `lower_bound -1`.

### 二分查找: 前一个和后一个

对于精确二分查找, 两个中点公式作用相同. 但如果要二分查找前一个或后一个时(目标值可能不存在), 中点的选取就有影响了.

例如, 对于升序数组, 查找比 t 大的第一个元素(后一个/upper_bound)

	m = s + (e-s)/2;
	if(arr[m] <= t){
		s = m + 1;
	}else{
		e = m;
	}

例如, 对于升序数组, 查找比 t 小的最后一个元素(前一个/lower_bound-1)

	m = s + (e-s+1)/2;
	if(arr[m] < t){
		s = m;
	}else{
		e = m - 1;
	}

__对于中点公式的选取, 与查找前一个还是后一个相关, 不可混用. 可以假设数组长度为 2 时分析得出.__

__注意"等于"这个条件可以合并到某一个分支, 将 3 个分支判断减少为 2 个.__

