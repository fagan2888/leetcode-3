# 解题要点

### 变量使用

为了简化代码, 定义如下下标变量:

	p: 新元素插入在 p 后面
	s: 区间的开始(包含)
	e: 区间的结束(包含)
	b: 区间的开始(包含)
	e: 区间的结束(不包含) std::end()
	m: 中点
	n: 用于遍历
	pre: 前序路径, 或者之前的计算结果, 用于向后序的调用传递数据

s, e 在一起时, e 包含
b, e 在一起时, e 不包含

### 中点公式

设数组起点和终点为 s 和 e, 那么中点 m 可以有两个选择:

	m = s + (e-s)/2

或者

	m = s + (e-s+1)/2 // +1中点公式
	m = e - (e-s)/2

当数组的长度为奇数时, 这两个公式算出的中点是一样的. 区别在于当数组的长度是偶数时, 中点偏向哪一边. 特别是当数组长度为 2 的时候, 中点指向第一个还是第二个? 第一个公式指向第一个, 第二个公式指向第二个.

另有中点公式: m = (s+e)/2, 比前面的公式更可能溢出.

### lower_bound 和 upper_bound

对于升序数组, 查找比 t 大的第一个元素(后一个/upper_bound)

	e = nums.size();
	m = s + (e-s)/2;
	if(arr[m] <= t){
		s = m + 1;
	}else{
		e = m;
	}
	return s;

注意, e 的初始值是 `nums.size()`, 而不是 `nums.size()-1`.

对于升序数组, 查找比 t 小的最后一个元素(前一个/lower_bound-1/反向upper_bound)

	e = nums.size(); // 或者 nums.size()-1
	m = e - (e-s)/2;
	if(arr[m] < t){
		s = m;
	}else{
		e = m - 1;
	}
	if(arr[s] < t) return s;
	else           return s-1;

### 组合 Combination

#### 对无重复元素的集合求组合

	void c1(vector<vector<int>> &ret, vector<int> &nums, int s, vector<int> &pre){
	    if(s == nums.size()){
	        return;
	    }   
	    pre.push_back(nums[s]);
	    ret.push_back(pre);
	    c1(ret, nums, s+1, pre);
	    pre.pop_back();
	    c1(ret, nums, s+1, pre);
	}

	void c2(vector<vector<int>> &ret, vector<int> &nums, int s, vector<int> &pre){
	    for(int i=s; i<nums.size(); i++){
	        pre.push_back(nums[i]);
	        ret.push_back(pre);
	        c2(ret, nums, i+1, pre);
	        pre.pop_back();
	    }   
	}

虽然 c1() 因为停止条件导致多递归了一层, 调用次数是 2^(n+1) 次, 但并不比 c2() 的 2^n 次更差, 因为优化方法很简单, 就是在递归前加判断, 让代码不那么简洁而已.

__c1() 处理逻辑属于渐进式递归, 一次前进一步. c2() 的处理逻辑是跳跃式.__

#### 对有重复元素的集合求组合

解决思路是先排序集合. 因为最终要对组合结果进行去重. 源数据如果是有序的, 那么按上面的方法求组合, 那么结果集中的子集(列表)也是有序的. 有序列表方便去重.

对源数据进行排序, 还有一个好处, 那就是在处理过程中去重.

去重的思路:

* 找出当前元素与前一个元素相同的情况.
* 根据前一个元素是否被加入到前序路径中, 决定当前元素也采用相同的策略.
* 为什么呢?
* 因为, 相同的 n 个元素, 求组合的方式数量组合(0-n), 与顺序无关.
* 第一个相同的元素处理了加入或者不加入两种条件(0 个或者 1 个), 后面的依次加入即可, 且必须加入.

对于 c1() 的优化, 如果不单独增加变量来存储"前一个元素是否被加入到前序路径中", 那就必须在路径中存储数组下标.

对于 c2() 的优化, 就不需要单独的变量, 因为它就是按下标进行处理的.

优化结果如下:



