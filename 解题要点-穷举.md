# 穷举法(Brute Force/Exhaustion)

穷举的方式有树遍历和图遍历两种.

## 树遍历: 渐进式(链式)

将问题拆分成一个父问题(原子问题)和一个子问题(剩下的), 父问题有两种状态: 被跳过或者被解决. 进一步递归地去解决子问题.

	func trc(pre_path, remain){
		root, remain2 = remain.split();
		trc(pre_path, remain2); // 父问题被跳过
		trc(pre_path + proc(root), remain2); // 父问题被解决
	}

## 图遍历: 跳跃式(组合式)

这种方式在解决求组合(子集)的问题时比较经典.

每一个问题不像树模型那样有唯一的一个入口(即根节点), 而是有多个入口. 问题本身就被入口所分割, 当选择任何一个入口时, 之前的问题都不需要去解决.

例如求一个有序集合的子集, 那么任何一个元素都是一个入口, 而这个入口元素之后的所有元素组成一个待解决的问题.

以 [1,2,3] 来举例, 1, 2, 3 是 3 个入口, 对应每一个入口, [2,3], [3], [] 就是等解决的问题.

因为选择了不同的入口之后, 问题自动被缩小了, 所以正好可以使用递归来解决.

	func grc(pre_path, remain){
		for(entrance, remain2 : remain){
			grc(pre_path + proc(entrance), remain2);
		}
	}

## 优化

缓存中间结果.
