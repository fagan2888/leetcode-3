# 穷举法(Brute Force/Exhaustion)

将问题分解成一个原子问题和若干个子问题, 原子问题可以直接被解决, 而子问题需要进一步分解才能被解决. 属于分而治之方法(Divide and Conquer Approach)大类下.

那么, 原子问题是树的父节点, 子问题是子节点. 从根节点到叶子节点的路径, 就是解决问题的完整路径. 解决的进度保存在前序路径中, 剩下的问题的解决将产生后序路径.

树的某些完整分支路径(根节点到叶子节点)或者整根树就是问题的答案. 例如最短路径, 可达路径, 组合.

## 渐进式(二分法)

将问题拆分成一个父问题(原子问题)和一个子问题(剩下的), 解决父问题之后, 结合结果, 继续解决子问题.

	func dnc(pre_path, remain){
		root, remain2 = remain.split();
		res = proc(root);
		rc(pre_path + res, remain2);
	}

## 跳跃式(组合式)

将问题拆分成一个父问题(原子问题)和一个子问题, 子问题做进一步分解成非原子问题.

	func rc(pre_path, remain){
		root, remain = remain.split();
		children = remain.split();
		res = proc(root);
		for(c : children){
			rc(pre_path + r, c);
		}
	}

这种方式叫组合式, 顾名思义, 就是类似生成子集(组合)的算法. 似乎只有求组合的时候才这么写.
